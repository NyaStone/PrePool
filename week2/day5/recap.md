# Pre-Pool recap

## Top 3

1. Plan ahead: before jumping into coding try to split up your task into as much smaller tasks as possible. Planning ahead this way avoids intense refactoring as you have to slove more proplems while coding.

2. Once you have things planned out, try to look if other people ran into the same kind of steps/issues you have to take. You may find some flaws to your thinking pattern, and solutions those. Don't reinvent the wheel if you have some available.

3. Use detailed naming patterns even if long, forgetting how your code works is guaranteed, and may occur very fast after being done. If you have to come back to refactor it some time later having explicit names will be very valuable. Avoid single letter variable names like the plague !

## Worst 3

1. AI tools are a double edge sword. While it can be a great deal of help to understand topics, prompting properly is rather hard. Prompting wrongly may and will lead to AI giving you  convincing inaccuracies or even errors. As such AI is a good tool to search information quickly, but not to produce reliable code, and thus you should not have it code for you, but rather ask it for advice in how to aproach a problem.

2. Lots of problems/exercises are very open ended and thus may feel hard to understand what is expected. Discussing them with other mates is often required to push us to a decent starting point.

3. Pygame is quite primitive, making it quite a lot of concepts to understand for newcommers in coding. Picking a framework to ease us in would be less confusing to get into UX design. Pygame comes with very few usefull components and most need to done yourself, or ripped from the internet, maybe without understandign them (For example a textinput component).

## Best Practices

- Uniformize naming conventions between team members, often programming languages already have some norms to follow. For example python devs have agreed to use snake case. (I used camel case out of my JS habbits, needs improvement)

- Test your code as you go along, better code splitting into smaller functions makes them easier to test for errors. (Unit tests)

- Perfection may be the worst enemy of a dev as it will take exponentially more time refactoring everything to perfection all the time. Find where to draw the line and call your implemention good enough and move on.

- Code review in a git project: Always have someone else review your code before merging it. This helps avoiding lots of breaking changes, as well as avoid painfull commit management to fix the project once broken.

## Self Evaluation

### Step 1 : myself


- **Can you navigate into a Linux filesystem?**

**Average**. Yes, cd, cp, mv are commands I use to navigate my WSL daily.

- **Can you write a simple program in Python?**

**Goat**.

- **Can you write a more complex program in Python?**

**Average**. Yes, I'd probably use some OOP to abuse design patters.

- **Can you find a bug in a Python program?**

**Goat**. Yes, if an exception is thrown reading the error message allows to understand where it's comming from. In other cases printing to examinate the state of the app as it runs can be very valluable.

- **Can you find information on Internet to solve a problem?**

**Goat**. Yes, I mostly know what keywords to look up to find awnsers on Stackoverflow/MozillaDev through google, and also prompting AI when some documentation is barely readable (ex Python).

- **Can you ask someone around you when you are stuck?**

**Average**. For the time beeing, I wasn't stuck, but discussing potential solution with mates has helped me find improvements to work on.

- **Can you help people around you?**

**Average**. Yes I try to be as much help as I can, but I avoid overdoing it with people who have very much trouble as I would just confuse them with the more advanced concepts I am using (Can't explain how I use OOP to someone who'se barely understanding functional programming) 

- **Can you test efficiently a program?**

**Average**. Yes but mostly no. I can think of the edge cases I should account for. But for propper testing the functional programming we've been doing, I still need to learn how to unit test with python.